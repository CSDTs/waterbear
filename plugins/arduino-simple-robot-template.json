{"aTemplates":[],"aTemplateNames":[],"aSetup":[],"aFiles":[],"content":["\n\n\n#include <AnalogEvent.h>\n#include <ButtonEvent.h>\n#include <TimedEvent.h>\n#include <LedControl.h>\n\n\/\/Pins for the Ardumoto\nconst int servo_1_pin = 5;\nconst int servo_2_pin = 6;\n\n\nint pwm_a = 3;  \/\/PWM control for motor outputs 1 and 2 is on digital pin 3\nint pwm_b = 11;  \/\/PWM control for motor outputs 3 and 4 is on digital pin 11\nint dir_a = 12;  \/\/direction control for motor outputs 1 and 2 is on digital pin 12\nint dir_b = 13;  \/\/direction control for motor outputs 3 and 4 is on digital pin 13\n\n\n\/\/Pins for the Access Space Waterbear Arduino Setup \nconst int ir_distance_1_pin  = A0;   \/\/ IR distance sensor 1\nconst int ir_distance_2_pin  = A1; \/\/ IR distance sensor 2\nconst int light_sensor_1_pin = A2; \/\/ Light Sensor 1\nconst int light_sensor_2_pin = A4; \/\/ Light Sensor 2 \/\/middle sensor currently not wired in\nconst int LED_Green_pin    = 10; \/\/ LEDs\nconst int LED_Under_pin    = 9; \/\/ LEDs\n\nconst String moving = \"moving\";\n\nconst String searching = \"searching\";\n\nconst int start_button_pin   = 4;\nconst int push_button_pin    = 4;\nconst int cutoff_pin         = 5;\nconst int bumper_1_pin       = 6;  \/\/ Bumper Button\nconst int bumper_2_pin       = 4;\n\n\/\/Variables\nlong   iSchedTime              = 0;\nconst  long start_button_pause = 1000;\n\nString current_motion_state    = \"stop\";\nString current_prog_state      = \"init\";\nString current_mode            = \"init\";\n\nint    speed_output_min        = 210;\nint    speed_output_max        = 250;\nint    speed_setting_max       = 10;\nint    speed_setting_current   = 1;\nint    speed_output_current    = 0;\nint    speed_setting_turning   = 1;\nint    speed_output_turning    = 0;\n\nint calc_speed_output(int speed)\n{\n  Serial.print(\"calc_speed_output \");\n  Serial.print(speed);\n  \n  int output = 0;\n  if(speed > 0)\n  {\n    if (speed < speed_setting_max)\n    {\n      output = (speed * ((speed_output_max - speed_output_min) \/ speed_setting_max)) + speed_output_min;\n    }\n    else\n    {\n      output = speed_output_max;\n    }\n  }\n  else\n  {\n    output = 0;\n  }\n  \n  Serial.print(\" output=\");\n  Serial.print(output);\n  Serial.println();\n  \n  return output;\n}\n\nvoid set_speed(int speed)\n{\n  Serial.println(\"set_speed\");\n\n  speed_output_current = calc_speed_output(speed); \n  speed_setting_current = speed;\n}\n\nint distance_calc(int iIrVal)\n{\n  Serial.println(\"distance_calc \");\n\n  float fIrVal = float(iIrVal);\n  float dist = 0.0;\n  if (fIrVal > 0)\n  {\n    dist = 12343.85 * pow(fIrVal, -1.15);\n  }\n  else\n  {\n    dist = 100.0 * 2;\n  }\n  return int(dist);\n}\n\nvoid bot_forward()\n{\n  Serial.println(\"bot_forward\");\n  if(current_prog_state == \"running\")\n  {\n    digitalWrite(dir_a, HIGH);\n    analogWrite(pwm_a, speed_output_current);\n    digitalWrite(dir_b, HIGH);\n    analogWrite(pwm_b, speed_output_current);\n    current_motion_state = \"forward\"; \n  }\n}\n\nvoid bot_backward()\n{\n  Serial.println(\"bot_backward\");\n  if(current_prog_state == \"running\")\n  {\n    digitalWrite(dir_a, LOW);\n    analogWrite(pwm_a, speed_output_current);\n    digitalWrite(dir_b, LOW);\n    analogWrite(pwm_b, speed_output_current);\n    current_motion_state = \"backward\"; \n  }\n}\n\nvoid bot_clockwise()\n{\n  Serial.println(\"bot_clockwise\");\n  if(current_prog_state == \"running\")\n  {\n    digitalWrite(dir_a, LOW);\n    analogWrite(pwm_a, speed_output_turning);\n    digitalWrite(dir_b, HIGH);\n    analogWrite(pwm_b, speed_output_turning);\n    current_motion_state = \"clockwise\";\n  }\n}\n\nvoid bot_anticlockwise()\n{\n  Serial.println(\"bot_anticlockwise\");\n  if(current_prog_state == \"running\")\n  {\n    digitalWrite(dir_a, HIGH);\n    analogWrite(pwm_a, speed_output_turning);\n    digitalWrite(dir_b, LOW);\n    analogWrite(pwm_b, speed_output_turning);\n    current_motion_state = \"anticlockwise\";\n  }\n}\n\nvoid bot_stop()\n{\n  Serial.println(\"bot_stop\");\n  digitalWrite(dir_a, HIGH);\n  analogWrite(pwm_a, 0);\n  digitalWrite(dir_b, HIGH);\n  analogWrite(pwm_b, 0);\n  current_motion_state = \"stop\";\n}\n\n\nvoid bot_clockwise_timed(TimerInformation* Sender)\n{\n  Serial.println(\"bot_clockwise_timed\");\n  bot_clockwise();\n}\n\nvoid bot_anticlockwise_timed(TimerInformation* Sender)\n{\n  Serial.println(\"bot_anticlockwise_timed\");\n  bot_anticlockwise();\n}\n\nvoid bot_backward_timed(TimerInformation* Sender)\n{\n  Serial.println(\"bot_backward_timed\");\n  bot_backward();\n}\n\nvoid bot_forward_timed(TimerInformation* Sender)\n{\n\n  Serial.println(\"bot_forward_timed\");\n  bot_forward();\n}\n\nvoid bot_stop_timed(TimerInformation* Sender)\n{\n  Serial.println(\"bot_stop_timed\");\n  bot_stop();\n}\n\n\nvoid onModeChange(String newmode)\n{\ncurrent_mode = newmode;\n\/\/onModeChange\/\/\n}\n\nvoid changeToMovingMode(TimerInformation* Sender){\n   onModeChange(\"moving\");\n}\n\nvoid changeToSearchingMode(TimerInformation* Sender){\n  onModeChange(\"searching\");\n}\n\n\nvoid onChange(AnalogPortInformation* Sender)\n{\n  Serial.print(\"onChange \");\n  Serial.print(Sender->pin);\n  Serial.print(\" value=\");\n  Serial.println(Sender->value);\n  \n\/\/onChange\/\/\n}\n\n\nvoid onDown(ButtonInformation* Sender)\n{\n  Serial.println(\"onDown\");\n  Serial.println(Sender->pin);\n  if(current_prog_state != \"init\")\n  {\n    \/\/onDown\/\/\n  }\n}\n\nvoid onUp(ButtonInformation* Sender)\n{\n  Serial.println(\"onUp\");\n  Serial.println(Sender->pin);\n\/\/onUp\/\/\n}\n\nvoid onHold(ButtonInformation* Sender)\n{\n  Serial.println(\"onHold\");\n  Serial.println(Sender->pin);\n\/\/onHold\/\/\n}\n\nvoid onDouble(ButtonInformation* Sender)\n{\n  Serial.println(\"onDouble\");\n  Serial.println(Sender->pin);\n\/\/onDouble\/\/\n}\n\n\nvoid cutoff_onUp(ButtonInformation* Sender)\n{\n  current_motion_state = \"cutoff\";\n  bot_stop();\n}\n\n\nvoid cutoff_onHold(ButtonInformation* Sender)\n{\n  if(current_motion_state == \"cutoff\")\n  {\n    \/\/current_motion_state = \"starting\";\n    \/\/TimedEvent.addDelayed(start_button_pause, onStartTime);\n  }\n}\n\nvoid start_bot()\n{\n  Serial.println(\"start_bot\");\n\n  iSchedTime = 0;\n\n  AnalogEvent.addAnalogPort(ir_distance_1_pin,  onChange, 10);\n  AnalogEvent.addAnalogPort(ir_distance_2_pin,  onChange, 10);\n  AnalogEvent.addAnalogPort(light_sensor_1_pin, onChange, 10);\n  AnalogEvent.addAnalogPort(light_sensor_2_pin, onChange, 10);\n  \n  ButtonEvent.addButton(push_button_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  \n  \n  ButtonEvent.addButton(bumper_1_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  \n  \/*\n  ButtonEvent.addButton(cutoff_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        cutoff_onUp,     \/\/onUp event function\n                        cutoff_onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  *\/                       \n  \n  LedControl.stopBlink(LED_Green_pin);\n  LedControl.turnOn(LED_Under_pin);\n  \n  current_prog_state = \"running\";\n  \n  \n  \n  \/\/any\/\/                      \n}\n\n\nvoid onStartTime(TimerInformation* Sender)\n{\n  Serial.println(\"onStartTime\");\n  start_bot();\n}\n\n\n\nvoid onStartDown(ButtonInformation* Sender)\n{\n  Serial.println(\"onStartDown\");\n  \n  if (Sender->pin == start_button_pin && current_prog_state == \"init\")\n  {\n    Serial.println(\"starting\");\n    current_prog_state = \"starting\";\n    TimedEvent.addDelayed(start_button_pause, onStartTime);\n    LedControl.stopBlink(LED_Green_pin);\n    LedControl.startBlink(LED_Green_pin, 100);\n  }\n}\n\nvoid loop()\n{\n  iSchedTime = 0;\n  AnalogEvent.loop();\n  TimedEvent.loop();\n  ButtonEvent.loop();\n  LedControl.loop();\n}\n\nvoid setup()\n{ \n  Serial.begin(9600);\n  Serial.println(\"setup\");\n  \n  pinMode(LED_Green_pin, OUTPUT);\n  pinMode(LED_Under_pin, OUTPUT);\n  \n\n  \n  LedControl.startBlink(LED_Green_pin, 500);\n  \n  pinMode(pwm_a, OUTPUT);  \/\/Set control pins to be outputs\n  pinMode(pwm_b, OUTPUT);\n  pinMode(dir_a, OUTPUT);\n  pinMode(dir_b, OUTPUT);\n \n  bot_stop();\n    \n  speed_output_turning = calc_speed_output(speed_setting_turning); \n  set_speed(speed_setting_current);\n  \n  \n  \/\/setup\/\/\n  \n  ButtonEvent.addButton(start_button_pin,       \/\/button pin\n                        onStartDown,   \/\/onStartDown event function \n                        \/\/change to another event but use status to check \n                        \/\/which runs and the other should be null\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  \n  \/\/TimedEvent.addDelayed(start_button_pause, onStartTime);                      \n}\n\n","\n\n\n#include <AnalogEvent.h>\n#include <ButtonEvent.h>\n#include <TimedEvent.h>\n#include <AFMotor.h>\n\n\/\/Adafruit Motor Shield setup\nAF_DCMotor motor_l(1);  \/\/motor numbers on the shield\nAF_DCMotor motor_r(3);  \/\/motor numbers on the shield\n\n\n\/\/Pins for the Access Space Waterbear Arduino Setup \nconst int ir_distance_1_pin  = A0;   \/\/ IR distance sensor 1\nconst int ir_distance_2_pin  = A1; \/\/ IR distance sensor 2\nconst int light_sensor_1_pin = A2; \/\/ Light Sensor 1\nconst int LED_Green_pin    = 12; \/\/ LEDs\nconst int start_button_pin   = 10;\nconst int cutoff_pin         = 9;\nconst int bumper_1_pin       = 8;  \/\/ Bumper Button\nconst int push_button_pin    = 7;\n\n\n\/\/Variables\nlong   iSchedTime              = 0;\nconst  long start_button_pause = 5000;\n\nString current_motion_state    = \"stop\";\nString current_prog_state      = \"init\";\nint    speed_output_min        = 100;\nint    speed_output_max        = 255;\nint    speed_setting_max       = 10;\nint    speed_setting_current   = 5;\nint    speed_output_current    = 0;\nint    speed_setting_turning   = 1;\nint    speed_output_turning    = 0;\n  \n\nint calc_speed_output(int speed)\n{\n  int output = 0;\n  if(speed > 0)\n  {\n    if (speed < speed_setting_max)\n    {\n      output = (speed_output_max - speed_output_min) \/ speed_setting_max;\n    }\n    else\n    {\n      output = speed_output_max;\n    }\n  }\n  return output;\n}\n\nvoid set_speed(int speed)\n{\n  speed_output_current = calc_speed_output(speed); \n  speed_setting_current = speed;\n}\n\n\nint distance_calc(int iIrVal)\n{\n  float fIrVal = float(iIrVal);\n  float dist = 0.0;\n        if (fIrVal > 0)\n        {\n            dist = 12343.85 * pow(fIrVal, -1.15);\n        }\n        else\n        {\n        \n            dist = 100.0 * 2;\n        }\n        return int(dist);\n}\n\n\nvoid bot_forward()\n{\n  if(current_motion_state == \"running\")\n  {\n    motor_l.run(FORWARD);\n    motor_l.setSpeed(speed_output_current);\n    motor_r.run(FORWARD);\n    motor_r.setSpeed(speed_output_current);\n    current_motion_state = \"forward\"; \n  }\n}\n\n\nvoid bot_backward()\n{\n  if(current_motion_state == \"running\")\n  {\n    motor_l.run(BACKWARD);\n    motor_l.setSpeed(speed_output_current);\n    motor_r.run(BACKWARD);\n    motor_r.setSpeed(speed_output_current);\n    current_motion_state = \"backward\"; \n  }\n}\n\nvoid bot_clockwise()\n{\n  if(current_motion_state == \"running\")\n  {\n    motor_l.run(FORWARD);\n    motor_l.setSpeed(speed_output_turning);\n    motor_r.run(BACKWARD);\n    motor_r.setSpeed(speed_output_turning);\n    current_motion_state = \"clockwise\";\n  }\n}\n\nvoid bot_anticlockwise()\n{\n  if(current_motion_state == \"running\")\n  {\n    motor_l.run(BACKWARD);\n    motor_l.setSpeed(speed_output_turning);\n    motor_r.run(FORWARD);\n    motor_r.setSpeed(speed_output_turning);\n    current_motion_state = \"anticlockwise\";\n  }\n}\n\nvoid bot_stop()\n{\n  motor_l.run(RELEASE);\n  motor_r.run(RELEASE);\n  current_motion_state = \"stop\";\n  \n}\n\nvoid bot_clockwise_timed(TimerInformation* Sender){\n  bot_clockwise();\n}\n\nvoid bot_anticlockwise_timed(TimerInformation* Sender){\n  bot_anticlockwise();\n}\n\nvoid bot_backward_timed(TimerInformation* Sender){\n  bot_backward();\n}\n\nvoid bot_forward_timed(TimerInformation* Sender){\n  bot_forward();\n}\n\nvoid bot_stop_timed(TimerInformation* Sender){\n  bot_stop();\n}\n\nvoid onChange(AnalogPortInformation* Sender) {\n\/\/onChange\/\/\n}\n\nvoid onDown(ButtonInformation* Sender) {\n\/\/onDown\/\/\n}\n\nvoid onUp(ButtonInformation* Sender) {\n\/\/onUp\/\/\n}\n\nvoid onHold(ButtonInformation* Sender) {\n\/\/onHold\/\/\n}\n\nvoid onDouble(ButtonInformation* Sender) {\n\/\/onDouble\/\/\n}\n\n\nvoid cutoff_onUp(ButtonInformation* Sender){\n  current_motion_state = \"cutoff\";\n  bot_stop();\n}\n\n\nvoid cutoff_onHold(ButtonInformation* Sender){\n  if(current_motion_state == \"cutoff\")\n  {\n    \/\/current_motion_state = \"starting\";\n    \/\/TimedEvent.addDelayed(start_button_pause, start);\n  }\n}\n\nvoid onStartTime(TimerInformation* Sender){\nstart();\n}\n\nvoid start()\n{\n  iSchedTime = 0;\n\n  AnalogEvent.addAnalogPort(ir_distance_1_pin,  onChange, 3);\n  AnalogEvent.addAnalogPort(ir_distance_2_pin,  onChange, 3);\n  AnalogEvent.addAnalogPort(light_sensor_1_pin, onChange, 3);\n  \n  \n  ButtonEvent.addButton(bumper_1_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  \n  ButtonEvent.addButton(push_button_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n  \n  \/*ButtonEvent.addButton(cutoff_pin,       \/\/button pin\n                        onDown,   \/\/onDown event function\n                        cutoff_onUp,     \/\/onUp event function\n                        cutoff_onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n *\/                       \n                        \n  current_motion_state = \"running\";\n  \n  \/\/any\/\/                      \n}\n\n\nvoid startbuttonDown(ButtonInformation* Sender)\n{\n  current_motion_state = \"starting\";\n  TimedEvent.addDelayed(start_button_pause, onStartTime);\n}\n\n\nvoid loop() {\n  iSchedTime = 0;\n  AnalogEvent.loop();\n  ButtonEvent.loop();\n  TimedEvent.loop();\n\n}\n\nvoid setup() {\n  \n  pinMode(bumper_1_pin, INPUT);           \/\/ set pin to input\n  digitalWrite(bumper_1_pin, HIGH);       \/\/ turn on pullup resistors\n  \n  pinMode(push_button_pin, INPUT);           \/\/ set pin to input\n  digitalWrite(push_button_pin, HIGH);       \/\/ turn on pullup resistors\n  \n  pinMode(cutoff_pin, INPUT);           \/\/ set pin to input\n  digitalWrite(cutoff_pin, HIGH);       \/\/ turn on pullup resistors\n  \n  \n  motor_l.setSpeed(200);\n  motor_l.run(RELEASE); \n  motor_r.setSpeed(200);\n  motor_r.run(RELEASE); \n    \n  speed_output_turning = calc_speed_output(speed_setting_turning); \n  speed_output_current = calc_speed_output(speed_setting_current);\n  \n  \/\/setup\/\/\n  \n  ButtonEvent.addButton(start_button_pin,       \/\/button pin\n                        startbuttonDown,   \/\/onDown event function\n                        onUp,     \/\/onUp event function\n                        onHold,   \/\/onHold event function\n                        1000,     \/\/hold time in milliseconds\n                        onDouble, \/\/onDouble event function\n                        200);     \/\/double time interval\n                        \n  TimedEvent.addDelayed(start_button_pause, onStartTime);                      \n}\n\n"],"name":["SWARP standard","SWARP adafruit"],"setup":[{"name":"SWARP standard","url":"www.stretchyboy.co.uk\/doku.php?id=myprojects:simple_waterbear_arduino_robot_programming","template":"arduino-simple-robot\/ardumoto.pde"},{"name":"SWARP adafruit","url":"","template":"arduino-simple-robot\/adafruit-motorshield.pde"}]}